#! /usr/bin/env bash



cmds=(\
     "Cancel/None         : exit command-n-control      " \
     "edit_tguide_cfg     : vi review/edit config       " \
     "build_firedancer    : gen/updt executables        " \
     "setup_wksp          : setup data stores           " \
     "reset_wksp          : refresh data stores         " \
     "report_wksp_stats   : shm/wskp stats              " \
     "run_tguard_monitor  : tguard activities           " \
     "run_tguard          : run tmon & tqos             " \
     "halt_tmon           : halt turbine monitor        " \
     "halt_tqos           : halt turbine qos daemon     " \
     "halt_main           : halt fd_tguard_run.bin      " \
     "stress_test         : blast pcaps at tguide       " \
     "view_log_excerpt    : less stats excerpt from log " \
)


INTERACTIVE=1
SCRIPT=$(realpath "$0") # so that go through softlink to true path
SCRIPT_PATH="$( cd -- "$(dirname "$SCRIPT")" >/dev/null 2>&1 ; pwd -P )"

APP_NAME="tguard"

NUMA_NUM=$(lscpu | grep "NUMA node(s):" | sed  -E "s/.*([0-9]+).*/\1/g")
if [[ $NUMA_NUM -gt "1" ]]; then
    CPU_AFFINITY="4-8/2"
    CPU_MONITOR="2"
else
    CPU_AFFINITY="2-4/1"
    CPU_MONITOR="1"
fi

SRC1=src/app/tguard
SRC2=build/linux/gcc/x86_64/bin
DST_TGSRC=src/app/tguard
DST_BUILD=build/linux/gcc/x86_64
case $SCRIPT_PATH in
    */${SRC1})
        REPO_ROOT="${SCRIPT_PATH/${SRC1}}"
        TGSRC_DIR="${SCRIPT_PATH/${SRC1}/${DST_TGSRC}}"
        BUILD_DIR="${SCRIPT_PATH/${SRC1}/${DST_BUILD}}" ;;
    */${SRC2})
        REPO_ROOT="${SCRIPT_PATH/${SRC2}}"
        TGSRC_DIR="${SCRIPT_PATH/${SRC2}/${DST_TGSRC}}"
        BUILD_DIR="${SCRIPT_PATH/${SRC2}/${DST_BUILD}}" ;;
    *)
        printf "\n     $(basename $0) need be from either ${SRC1} or ${SRC2}\n\n"
        exit 1 ;;
esac

stress_test() {
    if [[ $INTERACTIVE -eq "0" ]]; then
        if [[ $# -ne "4" ]]; then
            printf "\n     Insufficient arg parameters for running stress_test, needs: <replay_speed: y|n> <ifname> <loop_cnt> <pcap filename>\n\n" 
            return 1
        fi

        if [[ "$1" == "y" || $1 == "Y" ]]; then
            replay_speed="--topspeed"
        else
            replay_speed=""
        fi
        ifname="$2"
        loop_cnt="$3"
        pcapfile="$4"

        tcpreplay --preload-pcap ${replay_speed} --loop=${loop_cnt} --loopdelay-ms=0 -i ${ifname} ${pcapfile}
        return 1
    fi

    printf "\n\n"
    read -p "     replay pcap at max speed? (y/n) " userresponse
    if [[ "$userresponse" == "y" || "$userresponse" == "Y" ]]; then
        replay_speed="--topspeed"
    else
        replay_speed=""
    fi

    printf "\n\n"
    read -p "     interface name: " ifname
    printf "\n"
    ip a show ${ifname} up # 2>&1 /dev/null
    if [[ $? != "0" ]]; then
        printf "\nNetwork interface ${ifname} does not exist or is not up\n"
        return 1
    fi

    printf "\n\n"
    read -p "     injection loop count: " loop_cnt
    printf "\n"
    if [[ ! "$loop_cnt" =~ ^[0-9]+$ ]] ; then
        printf "\n     Invalid injection loop count $loop_cnt, must be a number\n\n"
        return 1
    fi

    printf "\n\n"
    read -p "     pcap pathname: " pcapfile_raw
    pcapfile=$(realpath $(eval echo "$pcapfile_raw")) # need 'eval echo "$pcapfile_raw"' for path start with "~" to work
    if [[ ! -f "${pcapfile}" ]]; then
        printf "\nFailed to locate pcap file ${pcapfile}\n"
        return 1
    fi

    printf "\n"
    loop_cnt_max="1024"
    if [[ "$loop_cnt" -ge "$loop_cnt_max" ]]; then
    	printf "\n     Invalid choice id $loop_cnt, need to be less than $loop_cnt_max\n\n"
    	return 1
    fi

    tcpreplay --preload-pcap ${replay_speed} --loop=${loop_cnt} --loopdelay-ms=0 -i ${ifname} ${pcapfile}
}

view_log_excerpt() {
    ls -lrt  /tmp/fd*                      |\
    tail -n1                               |\
    rev                                    |\
    cut -d' ' -f1                          |\
    rev                                    |\
    xargs grep -i 'txtime'                 |\
    sed 's/.*TXtime_ns/tx_time_ns/'        |\
    sed 's/(.*tx_ena.*rx_cnt/     rx_cnt/' |\
    sed 's/).*tx_cod.*tx_idx/)    tx_idx/' |\
    less
}

run_compile() {
    source ./activate-opt

    HOSTDOMAIN=$(hostname -d)
    [[ "$HOSTDOMAIN" =~ ^.*\.jumptrading\.com$ ]] && source ./activate-gcc

    MACHINE=linux_gcc_x86_64 COMPILER=gcc EXTRAS=libpcap make -j
}

edit_tguide_cfg() {
    vi ${TGSRC_DIR}/fd_tguard_cfg.h
    # run_compile
}

build_firedancer() {
    ./deps.sh
    run_compile
}

check_file_exist() {
    file=$1
    if [[ ! -f ${file} ]]; then
        printf "\n     ${file}  does not exist, you need to run build_firedancer first\n\n"
        return 1 # need to return non-0 on fail to work with 'check_file_exist $cmd || return'
    else
        return 0 # need to return 0 on success to work with 'check_file_exist $cmd || return'
    fi
}

get_wksp_cfg() {
    cfg_file="tmp/${APP_NAME}.cfg"
    if [[ -f ${cfg_file} ]]
    then
        . ${cfg_file}
        return 0 # need to return 0 on success to work with 'check_file_exist $cmd || return'
    else
        printf "\n     ${cfg_file}  does not exist, you need to run setup_wksp first\n\n"
        return 1 # need to return non-0 on fail to work with 'check_file_exist $cmd || return'
    fi
}

report_wksp_stats() {
    ${BUILD_DIR}/bin/fd_shmem_cfg query
    cfg_file="tmp/${APP_NAME}.cfg"
    if [[ -f ${cfg_file} ]]
    then
        printf "Sourcing current cfg file ${cfg_file}...\n"
        . ${cfg_file}
        printf "    Obtained from ${cfg_file}:   APP=${APP}   POD=${POD}   MAIN_CNC=${MAIN_CNC}\n\n"
        ${BUILD_DIR}/bin/fd_wksp_ctl  query ${APP}.wksp
        ${BUILD_DIR}/bin/fd_pod_ctl   list  ${POD}
    else
        printf "  ${cfg_file} does not exist, need to run 'setup_wksp' first\n"
        return # exit 1
    fi
}

setup_wksp() {
    # cleanup just in case
    check_file_exist ${BUILD_DIR}/bin/fd_tguard_fini || return 1
    sudo ${BUILD_DIR}/bin/fd_tguard_fini ${APP_NAME}

    check_file_exist ${BUILD_DIR}/bin/fd_shmem_cfg
    sudo ${BUILD_DIR}/bin/fd_shmem_cfg reset
    sudo ${BUILD_DIR}/bin/fd_shmem_cfg fini
    
    # init shm
    sudo rm -rf /mnt/.fd
    sudo ${BUILD_DIR}/bin/fd_shmem_cfg init 0700 ${USER} ""

    # allocate shm for wksp
    #    allocated pages for NUMA 0
    sudo ${BUILD_DIR}/bin/fd_shmem_cfg   alloc 8 gigantic 0   alloc 512 huge 0
    if [ "$?" != "0" ]; then
        printf "\n     'fd_shmem_cfg alloc...' failed.\n"
        printf "          likely it is due to some rogue process hogging to the hugepages\n"
        printf "       The solution is to find the rogue process by running:\n"
        printf "           sudo grep huge /proc/*/numa_maps\n"
        printf "         then rerun shmem alloc after killing the rogue process.\n\n"
        return # exit 1
    fi
    #    allocated pages for NUMA 1, OK to fail as some nodes have only 1 NUMA
    sudo ${BUILD_DIR}/bin/fd_shmem_cfg   alloc 8 gigantic 1   alloc 512 huge 1

    # create wksp
    check_file_exist ${BUILD_DIR}/bin/fd_tguard_init || return 1
    sudo ${BUILD_DIR}/bin/fd_tguard_init  ${APP_NAME} ${CPU_AFFINITY} ${BUILD_DIR}
    if [ "$?" != "0" ]; then
        printf "\n     Failed running \"${BUILD_DIR}/bin/fd_tguard_init  ${APP_NAME} ${CPU_AFFINITY} ${BUILD_DIR}\"\n\n"
        return # exit 1
    fi
    sudo chown ${USER} /mnt/.fd/.gigantic/${APP_NAME}.wksp
    
    # report wksp stats
    report_wksp_stats
}

reset_wksp() {
    check_file_exist ${BUILD_DIR}/bin/fd_tguard_fini || return 1
    sudo ${BUILD_DIR}/bin/fd_tguard_fini ${APP_NAME}
    
    check_file_exist ${BUILD_DIR}/bin/fd_tguard_init || return 1
    sudo ${BUILD_DIR}/bin/fd_tguard_init  ${APP_NAME} ${CPU_AFFINITY} ${BUILD_DIR}
    sudo chown ${USER} /mnt/.fd/.gigantic/${APP_NAME}.wksp
}

run_tguard_monitor() {
    check_file_exist ${BUILD_DIR}/bin/fd_tguard_mon || return 1

    # printf "\n\n"
    # read -n 1 -p "     Enable default logging in /tmp? (y|n:default)" userresponse
    # if [ "$userresponse" == "y" ]; then
    #         unset FD_LOG_PATH
    #         printf "\n     Default loggined enabled in /tmp\n\n"
    # else
    #         export FD_LOG_PATH=""
    #         printf "\n     Default loggined disabled\n\n"
    # fi
    export FD_LOG_PATH="" # always disable logging for monitor to simplify running while avoiding disk out of space

    taskset -c ${CPU_MONITOR} ${BUILD_DIR}/bin/fd_tguard_mon ${APP_NAME} --duration 250000000000000000 # --dt-min 100000000 --dt-max 100000000
}

run_tguard() {
    check_file_exist ${BUILD_DIR}/bin/fd_tguard_run || return 1

    if [[ $INTERACTIVE -eq "0" ]]; then
        export FD_LOG_PATH=""
    else
        printf "\n\n"
        read -n 1 -p "     Enable default logging in /tmp? (y|n:default)" userresponse

        if [ "$userresponse" == "y" ]; then
                unset FD_LOG_PATH
                printf "\n     Default loggined enabled in /tmp\n\n"
        else
                export FD_LOG_PATH=""
                printf "\n     Default loggined disabled\n\n"
        fi
    fi

    ${BUILD_DIR}/bin/fd_tguard_run ${APP_NAME} ${CPU_AFFINITY}
}

halt_tqos() {
    get_wksp_cfg || return 1

    check_file_exist ${BUILD_DIR}/bin/fd_tango_ctl || return 1
    ${BUILD_DIR}/bin/fd_tango_ctl signal-cnc ${TQOS_CNC} halt
}

halt_tmon() {
    get_wksp_cfg || return 1

    check_file_exist ${BUILD_DIR}/bin/fd_tango_ctl || return 1
    ${BUILD_DIR}/bin/fd_tango_ctl signal-cnc ${TMON_CNC} halt
}

halt_main() {
    get_wksp_cfg || return 1

    check_file_exist ${BUILD_DIR}/bin/fd_tango_ctl || return 1
    ${BUILD_DIR}/bin/fd_tango_ctl signal-cnc ${MAIN_CNC} halt
}

get_clean_cmd() {
    raw_cmd=$1
    echo "$raw_cmd" | sed "s/ *:.*//"
}

prompt_and_eval_cmd() {
    if [[ $# == "0" ]]; then
        INTERACTIVE=1
        printf "\n     Choices available to run:\n"
        for (( i=0; i<${#cmds[@]}; i++ ));
        do
        if [[ $i -lt 10 ]]; then
            padding=" "
        else
            padding=""
        fi
            printf "        $(( i )):${padding} ${cmds[$i]}\n"
        done
        
        printf "\n"
        read -p "     Enter choice id to run: " userresponse1
    else
        INTERACTIVE=0
        userresponse1=$1
    fi

    if [[ ! "$userresponse1" ]]; then
        return 1
    fi
    if [[ ! "$userresponse1" =~ ^[0-9]+$ ]] ; then
        printf "\n     Invalid choice id $userresponse1, need to be a number in range [0, ${#cmds[@]})\n\n"
        return 1
    fi
    if [[ "$userresponse1" -ge ${#cmds[@]} ]]; then
    	printf "\n     Invalid choice id $userresponse1, need to be less than ${#cmds[@]}\n\n"
    	return 1
    elif [[ ${cmds[$userresponse1]} =~ "Cancel/None" ]]; then
    	printf "\n\n     Stopping command running per user choice $userresponse1: ${cmds[$userresponse1]}\n\n"
    	exit 0
    else
	    userresponse2="y"
    	if [ "$userresponse2" != "n" ]; then
            printf "\n"
                cmd=$(get_clean_cmd ${cmds[$userresponse1]}) 
                eval ${cmd}
            printf "\n     ^ Done running command:  ${cmd}\n"
    	else
    	    printf "\n\n     Skipping running command $userresponse1: ${cmds[$userresponse1]}\n\n"
    	fi	
    fi
}

#
## main
#
cd ${REPO_ROOT}
if [[ $# -ge "1" ]]; then
    for cid in "${@}"; do
      # making `stress_test` an easter egg, 
      #   => can be run like: fd_tguard_cnc stress_test y lo 1 test.pcap
      if [[ $cid == "stress_test" ]]; then
        INTERACTIVE=0
        shift 1
        stress_test ${@}
        break
      else
        prompt_and_eval_cmd ${cid}
      fi
    done
else
    for _ in {1..50}; do printf "\n\n\n";  done
    for (( ; ; )); do prompt_and_eval_cmd; done
fi